<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bOkaI&#39;s Blog</title>
  
  
  <link href="http://iamzbk.github.io/atom.xml" rel="self"/>
  
  <link href="http://iamzbk.github.io/"/>
  <updated>2022-08-23T00:29:34.808Z</updated>
  <id>http://iamzbk.github.io/</id>
  
  <author>
    <name>bOkaI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于最小生成树</title>
    <link href="http://iamzbk.github.io/2022/08/14/MST/"/>
    <id>http://iamzbk.github.io/2022/08/14/MST/</id>
    <published>2022-08-14T11:15:21.000Z</published>
    <updated>2022-08-23T00:29:34.808Z</updated>
    
    <content type="html"><![CDATA[<p>前置芝士：搜索</p><h2 id="什么时候用最小生成树算法"><a href="#什么时候用最小生成树算法" class="headerlink" title="什么时候用最小生成树算法"></a>什么时候用最小生成树算法</h2><p>一般来说，最小生成树算法是将一个无向图转化为一棵边权和最小的树</p><h2 id="各种算法"><a href="#各种算法" class="headerlink" title="各种算法"></a>各种算法</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>前置芝士：并查集</p><p>Kruskal算法采用贪心的思想，每选择当前未选过且边权最小的边，即枚举边</p><p>判断如果添加了这条边，不会构成闭合环路(树的特性)的话，那就选择这条边成为生成树的一边，</p><p>最终会选出$(n-1)$条边组成最小生成树,</p><p>判断闭合回路采用<strong>并查集</strong>算法；</p><blockquote><p>引用</p><p><a href="http://c.biancheng.net/algorithm/kruskal.html">kruskal算法（克鲁斯卡尔算法）详解</a></p></blockquote><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;    <span class="comment">//可以写成循环</span></span><br><span class="line">    枚举每一条边&#123;</span><br><span class="line">        如果是自环&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        如果加入这条边不会构成闭合回路&#123;  <span class="comment">//并查集操作</span></span><br><span class="line">            <span class="comment">//如果有需要,可以进行统计</span></span><br><span class="line">            边数+<span class="number">1</span>;</span><br><span class="line">            合并这两个点;   <span class="comment">//并查集操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现(洛谷P3366):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//define int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to,val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">5005</span>],sum,cnt,f=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">node edge[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----并查集部分------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[pos]==pos)&#123;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(fa[pos]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hb</span><span class="params">(<span class="type">int</span> pos1,<span class="type">int</span> pos2)</span></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(pos1)]=<span class="built_in">find</span>(pos2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----并查集结束------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edge,edge+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].from==edge[i].to)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(edge[i].from)!=<span class="built_in">find</span>(edge[i].to))&#123;</span><br><span class="line">            sum+=edge[i].val;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">hb</span>(edge[i].from,edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5005</span>;i++)&#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        edge[i]=node&#123;x,y,z&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span>(cnt!=n<span class="number">-1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><h3 id="三算法的比较"><a href="#三算法的比较" class="headerlink" title="三算法的比较"></a>三算法的比较</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前置芝士：搜索&lt;/p&gt;
&lt;h2 id=&quot;什么时候用最小生成树算法&quot;&gt;&lt;a href=&quot;#什么时候用最小生成树算法&quot; class=&quot;headerlink&quot; title=&quot;什么时候用最小生成树算法&quot;&gt;&lt;/a&gt;什么时候用最小生成树算法&lt;/h2&gt;&lt;p&gt;一般来说，最小生成树算法是将一</summary>
      
    
    
    
    
    <category term="OI" scheme="http://iamzbk.github.io/tags/OI/"/>
    
    <category term="算法" scheme="http://iamzbk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于线段树</title>
    <link href="http://iamzbk.github.io/2022/08/11/Segment-Tree/"/>
    <id>http://iamzbk.github.io/2022/08/11/Segment-Tree/</id>
    <published>2022-08-11T06:00:21.000Z</published>
    <updated>2022-08-15T06:52:33.354Z</updated>
    
    <content type="html"><![CDATA[<p>前置芝士：二叉树</p><h2 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h2><p>线段树是种数据结构，通过数学的方式将线段变成树；</p><p>用O(n)的时间预处理，之后可以用O(logn)的复杂度进行查询，修改等操作</p><p>但虽然说是模板，但容易因为小部分没理解而出错</p><h2 id="为什么用线段树"><a href="#为什么用线段树" class="headerlink" title="为什么用线段树"></a>为什么用线段树</h2><p>从定义中得知，线段树的最大优势是“一劳永逸”，适用于有多次区间查询，修改的情况，</p><p>像这样：</p><blockquote><p>已知一个数列，你需要进行下面三种操作：</p><p>1.将某区间每一个数加上k</p><p>2.将某区间某一个数加上k</p><p>3.求出某区间每一个数的和</p></blockquote><h2 id="线段树怎么用"><a href="#线段树怎么用" class="headerlink" title="线段树怎么用"></a>线段树怎么用</h2><p>线段树有多种版本</p><h3 id="最基础经典的线段树"><a href="#最基础经典的线段树" class="headerlink" title="最基础经典的线段树"></a>最<del>基础</del>经典的线段树</h3><p>总体利用二叉树的一个简单的规律：</p><blockquote><p>root×2&#x3D;leaf1，root×2+1&#x3D;leaf2</p></blockquote><h4 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h4><p>关于树的结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;  <span class="comment">//注意:这里指该节点包含区间的左右边界，而不是左右节点的编号</span></span><br><span class="line">    <span class="comment">//左右节点的编号是通过规律计算得出的</span></span><br><span class="line">    <span class="comment">//也就是说,在实际运算中采用结构体中的l,r</span></span><br><span class="line">    <span class="comment">//在数组操作中使用通过计算出的编号</span></span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">//存储的值,可以多个</span></span><br><span class="line">    <span class="type">int</span> len;  <span class="comment">//即区间长度,就是(r-l)</span></span><br><span class="line">    <span class="type">int</span> mark; <span class="comment">//某种标记,可以多个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><p>介绍递归建树的方式</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 建树(当前节点，当前区间左边界，当前区间右边界)&#123;</span><br><span class="line">    tree[当前节点].左边界=当前区间左边界,tree[当前节点].右边界=当前区间右边界;</span><br><span class="line">    计算当前节点的len;</span><br><span class="line">    <span class="keyword">if</span>(区间左边界==区间右边界)&#123;  <span class="comment">//缩小到只包含一个节点了</span></span><br><span class="line">        当前节点的值=轮到的点的值;    <span class="comment">//如果是输入数列，也可以认为是当前读到的值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则继续递归(二分)</span></span><br><span class="line">    当前区间中点=(当前区间左边界+当前区间右边界)/<span class="number">2</span>;</span><br><span class="line">    建树(当前节点左子节点编号,当前区间左边界,当前区间中点);</span><br><span class="line">    建树(当前节点右子节点编号,当前区间中点,当前区间右边界);</span><br><span class="line">    向上传值(当前节点); <span class="comment">//为了之后的计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[pos].l=l,tree[pos].r=r;</span><br><span class="line">    tree[pos].len=r-l;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[pos].val=arr[p];  <span class="comment">//tree[pos].val=read();</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(pos&lt;&lt;<span class="number">1</span>,l,mid); <span class="comment">//和build(pos*2,l,mid)一个意思</span></span><br><span class="line">    <span class="built_in">build</span>(pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid,r);  <span class="comment">//和build(pos*2+1,mid,r)一个意思</span></span><br><span class="line">    <span class="built_in">pushup</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h4><p>利用规律二分查找</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> 单点查询(想要找点的位置，当前节点的位置)&#123;</span><br><span class="line">    <span class="keyword">if</span>(找到了)&#123;</span><br><span class="line">        <span class="keyword">return</span> 当前节点的值;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分</span></span><br><span class="line">    当前区间中点的位置=(当前节点的左子点+当前节点的右子点)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(当前区间中点的位置&gt;想要改的点的位置)&#123;</span><br><span class="line">        <span class="keyword">return</span> 单点查询(想要改的点的位置，当前节点的位置*<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> 单点查询(想要改的点的位置，当前节点的位置*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//高级操作(当前节点); //如果有需要</span></span><br><span class="line">    <span class="comment">//向上传值(当前节点); //如果有需要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">one_query</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tl=now&lt;&lt;<span class="number">1</span>,tr=now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;  <span class="comment">//求左右子节点编号</span></span><br><span class="line">    <span class="keyword">if</span>(pos==now)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[pos].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pushdown(now)  //如果有需要</span></span><br><span class="line">    <span class="type">int</span> mid=(tree[pos].r+tree[pos].l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;pos)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">one_query</span>(tl,pos);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">one_query</span>(tr,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h4><p>也是采用二分的思想，与单点查询相似</p><p>是下面区间更新的特殊情况</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 单点修改(想要改的点的位置，当前节点的位置，要改成的值)&#123;</span><br><span class="line">    <span class="keyword">if</span>(找到了)&#123;</span><br><span class="line">        修改;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分</span></span><br><span class="line">    当前区间中点的位置=(当前节点的左子点+当前节点的右子点)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(当前区间中点的位置&gt;想要改的点的位置)&#123;</span><br><span class="line">        单点修改(想要改的点的位置，当前节点的左子节点，要改成的值);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        单点修改(想要改的点的位置，当前节点的右子节点，要改成的值);</span><br><span class="line">    &#125;</span><br><span class="line">    向上传值(当前节点);  <span class="comment">//用于更新数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">one_update</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> now,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tl=now&lt;&lt;<span class="number">1</span>,tr=now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;  <span class="comment">//求左右子节点编号</span></span><br><span class="line">    <span class="keyword">if</span>(pos==now)&#123;</span><br><span class="line">        tree[pos].val=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tree[now].l+tree[now].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;pos)&#123;</span><br><span class="line">        <span class="built_in">one_update</span>(pos,tl,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">one_update</span>(pos,tr,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于1.1与1.2的pushup()补充:</p><p>这里的pushup只需要有求和的功能,因此:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    tr[pos].val=(tr[pos&lt;&lt;<span class="number">1</span>].val+tr[pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但pushup()是自定义的，根据需要定制</p><h4 id="区间询问"><a href="#区间询问" class="headerlink" title="区间询问"></a>区间询问</h4><p>通过二分找到左边界点和右边界点，过程中对于区间内的点直接操作(比如相加)</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 区间查询(当前节点,要查的区间的左边界,要查的区间的右边界)&#123;</span><br><span class="line">    <span class="keyword">if</span>(当前这个点统计的区间在要查的区间范围内)&#123;   <span class="comment">//或者说&quot;包含的区间&quot;</span></span><br><span class="line">        <span class="keyword">return</span> 当前点的值;</span><br><span class="line">    &#125;</span><br><span class="line">    定义将要返回值为<span class="number">0</span></span><br><span class="line">    <span class="comment">//如果需要，放置一些高级操作的代码</span></span><br><span class="line">    <span class="comment">//开始二分</span></span><br><span class="line">    当前区间中点的位置=(当前节点的左子点+当前节点的右子点)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(要查的区间的左边界&lt;=当前区间中点的位置)&#123;</span><br><span class="line">        进行二分和操作;</span><br><span class="line">        <span class="comment">//想这样</span></span><br><span class="line">        返回值+=区间查询(当前节点的左子节点,要查的区间的左边界,要查的区间的右边界);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(要查的区间的右边界&gt;当前区间中点的位置)&#123;</span><br><span class="line">        进行二分和操作;</span><br><span class="line">        <span class="comment">//想这样</span></span><br><span class="line">        返回值+=区间查询(当前节点的右子节点,要查的区间的左边界,要查的区间的右边界);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tl=now&lt;&lt;<span class="number">1</span>,tr=now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;  <span class="comment">//求左右子节点编号</span></span><br><span class="line">    <span class="keyword">if</span>(tl=&gt;l&amp;&amp;tr&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[now].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//pushdown()</span></span><br><span class="line">    <span class="type">int</span> mid=(tree[now].l+tree[now].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line">        ret+=<span class="built_in">query</span>(tree[now].l,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)&#123;</span><br><span class="line">        ret+=<span class="built_in">query</span>(tree[now].r,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稍进阶的线段树"><a href="#稍进阶的线段树" class="headerlink" title="稍进阶的线段树"></a>稍进阶的线段树</h3><h4 id="区间更新"><a href="#区间更新" class="headerlink" title="区间更新"></a>区间更新</h4><p>这里引用洛谷一位大佬对区间的解释:</p><blockquote><h3 id="从分块思想上解释如何区间修改："><a href="#从分块思想上解释如何区间修改：" class="headerlink" title="从分块思想上解释如何区间修改："></a>从分块思想上解释如何区间修改：</h3><p>分块的思想是通过将整个序列分为有穷个小块，对于要查询的一段区间，总是可以整合成 <strong>k</strong> 个所分块与 <strong>m</strong> 个单个元素的信息</p><p>那么我们可以反过来思考这个问题：对于一个要修改的、长度为 l<strong>l</strong> 的区间来说，</p><p>可以看做由一个长度为$2^{\log(\lfloor{n}\rfloor)}$ 和为剩下的元素（或者小区间组成），那么我们就可以先将其拆分成线段树上节点所示的区间，之后分开处理：</p><p><em><strong>如果单个元素被包含就只改变自己，如果整个区间被包含就修改整个区间。</strong></em></p><p>其实好像这个在分块里不是特别简单地实现，但是在线段树里，无论是元素还是区间都是线段树上的一个节点， <strong>所以我们不需要区分区间还是元素</strong> ，加个判断就好。</p></blockquote><hr><p>从之前的操作中可以看出，区间更新和区间查询并不会更新到底;</p><p>同时，对于要求中的区间”批量”更新，通过$n$次单点修改的方式是不够优的;</p><p>因此，需要有一个关键变量，暂且命名为<strong>Mark</strong>,该变量将记录区间的改变;</p><p>就是将树根上干的事记录下来;</p><p>然后<strong>下次</strong>查到它子树上时顺便传下去;</p><p>因此要对之前的update()函数进行<del>一点点</del>修改</p><p>伪代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 区间修改(想要改的区间的左边界,想要改的区间的右边界,当前节点的位置,要进行的操作)&#123;</span><br><span class="line">    <span class="keyword">if</span>(当前这个点统计的区间在要查的区间范围内)&#123;   <span class="comment">//或者说&quot;包含的区间&quot;</span></span><br><span class="line">        对这个点进行操作;</span><br><span class="line">        记录改变;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//考虑子节点所维护的区间可能因为Mark的存在而没有修改，因此将Mark下放</span></span><br><span class="line">    下传函数(当前节点);</span><br><span class="line">    <span class="comment">//二分</span></span><br><span class="line">    想要改区间中点的位置=(想要改的区间的左边界+想要改的区间的右边界)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(当前点的左子节点的位置&lt;=想要改区间中点的位置)&#123;   <span class="comment">//在左边有分布</span></span><br><span class="line">        区间修改(想要改的区间的左边界,想要改的区间的右边界,当前节点的左子节点的位置,要进行的操作);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(当前点的右子节点的位置&gt;想要改区间中点的位置)&#123;   <span class="comment">//在右边有分布</span></span><br><span class="line">        区间修改(想要改的区间的左边界,想要改的区间的右边界,当前节点的右子节点的位置,要进行的操作);</span><br><span class="line">    &#125;</span><br><span class="line">    向上传值(当前节点);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">interval_update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//根据要完成的操作定义参数</span></span><br><span class="line">    <span class="comment">//这里是加法</span></span><br><span class="line">    <span class="type">int</span> tl=pos&lt;&lt;<span class="number">1</span>,tr=pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>; <span class="comment">//求左右字节点编号</span></span><br><span class="line">    <span class="keyword">if</span>(tree[now].l&gt;=l&amp;&amp;tree[now].r&lt;=r)&#123;</span><br><span class="line">        tree[pos].val+=tree[pos].len*data;</span><br><span class="line">        tree[pos].mark+=data; <span class="comment">//记录改变,这里的Mark直接当值用</span></span><br><span class="line">        <span class="comment">//不能直接等于</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若不在范围内</span></span><br><span class="line">    <span class="built_in">pushdown</span>(pos);</span><br><span class="line">    <span class="comment">//二分</span></span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[pos].l&lt;=mid)&#123;</span><br><span class="line">        <span class="built_in">interval_update</span>(l,r,tl,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[pos].r&gt;mid)&#123;</span><br><span class="line">        <span class="built_in">interval_update</span>(l,r,tr,data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对于区间更新中的下传函数补充"><a href="#对于区间更新中的下传函数补充" class="headerlink" title="对于区间更新中的下传函数补充"></a>对于区间更新中的下传函数补充</h4><p>根据要求自定义</p><p>伪代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 下传函数(从哪开始下传)&#123;</span><br><span class="line">    <span class="keyword">if</span>(根据传入点的Mark已激活)&#123;</span><br><span class="line">对传入点的两个子节点的Mark标志激活;</span><br><span class="line">        各种各样的操作;</span><br><span class="line">        取消激活传入节点的Mark标志激活;</span><br><span class="line">        <span class="comment">//根据情况,三步操作可能可以互换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[pos].lazy)&#123;  <span class="comment">//自定义判断</span></span><br><span class="line">        <span class="comment">//激活子节点</span></span><br><span class="line">        <span class="type">int</span> l=pos&lt;&lt;<span class="number">1</span>,r=pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>; <span class="comment">//方便阅读</span></span><br><span class="line">        tree[l].mark+=tree[pos].mark; <span class="comment">//不能直接等于</span></span><br><span class="line">        tree[r].mark+=tree[pos].mark;</span><br><span class="line">        <span class="comment">//自定义操作</span></span><br><span class="line">        <span class="comment">//加法</span></span><br><span class="line">        tree[l].val+=tree[l].len*tree[pos].mark;</span><br><span class="line">        tree[r].val+=tree[r].len*tree[pos].mark;</span><br><span class="line">        <span class="comment">//取消激活父节点</span></span><br><span class="line">        tree[pos].mark=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树的本体到此结束;</p><p>引用一位学长对于线段树的认知:</p><blockquote><p>线段树的用法很多</p><p>打开洛谷就会发现线段树在实战中经常和其他算法一起使用;</p><p>所以线段树实际上就是个基础算法，用处多而已;</p><p>不可能只会一个线段树就能杀穿全场;</p><p>比赛终究靠的不是人品ex</p></blockquote><p>下面都是是线段树的变种</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前置芝士：二叉树&lt;/p&gt;
&lt;h2 id=&quot;什么是线段树&quot;&gt;&lt;a href=&quot;#什么是线段树&quot; class=&quot;headerlink&quot; title=&quot;什么是线段树&quot;&gt;&lt;/a&gt;什么是线段树&lt;/h2&gt;&lt;p&gt;线段树是种数据结构，通过数学的方式将线段变成树；&lt;/p&gt;
&lt;p&gt;用O(n)的</summary>
      
    
    
    
    
    <category term="OI" scheme="http://iamzbk.github.io/tags/OI/"/>
    
    <category term="数据结构" scheme="http://iamzbk.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://iamzbk.github.io/2022/08/04/article-title/"/>
    <id>http://iamzbk.github.io/2022/08/04/article-title/</id>
    <published>2022-08-04T07:05:42.046Z</published>
    <updated>2022-08-04T07:07:20.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="First-Test"><a href="#First-Test" class="headerlink" title="First Test"></a><strong>First Test</strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;First-Test&quot;&gt;&lt;a href=&quot;#First-Test&quot; class=&quot;headerlink&quot; title=&quot;First Test&quot;&gt;&lt;/a&gt;&lt;strong&gt;First Test&lt;/strong&gt;&lt;/h2&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://iamzbk.github.io/2022/08/03/hello-world/"/>
    <id>http://iamzbk.github.io/2022/08/03/hello-world/</id>
    <published>2022-08-03T12:44:13.112Z</published>
    <updated>2022-08-04T07:55:20.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a><strong>Hello World!</strong></h1><h3 id="记创建的第一天"><a href="#记创建的第一天" class="headerlink" title="记创建的第一天;"></a>记创建的第一天;</h3><p>Good luck for the following days!</p><h2 id="●’◡’●"><a href="#●’◡’●" class="headerlink" title="(●’◡’●)"></a>(●’◡’●)</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World!&quot;&gt;&lt;/a&gt;&lt;strong&gt;Hello World!&lt;/strong&gt;&lt;/h1&gt;&lt;h3 id=&quot;记创建的第一天&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
