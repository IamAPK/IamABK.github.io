<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bOkaI&#39;s Blog</title>
  
  
  <link href="http://iamzbk.github.io/atom.xml" rel="self"/>
  
  <link href="http://iamzbk.github.io/"/>
  <updated>2022-08-12T10:21:59.332Z</updated>
  <id>http://iamzbk.github.io/</id>
  
  <author>
    <name>bOkaI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于线段树</title>
    <link href="http://iamzbk.github.io/2022/08/11/Segment-Tree/"/>
    <id>http://iamzbk.github.io/2022/08/11/Segment-Tree/</id>
    <published>2022-08-11T06:00:21.000Z</published>
    <updated>2022-08-12T10:21:59.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h2><p>线段树是种数据结构，通过数学的方式将线段变成树；</p><p>用O(n)的时间预处理，之后可以用O(logn)的复杂度进行查询，修改等操作</p><h2 id="为什么用线段树"><a href="#为什么用线段树" class="headerlink" title="为什么用线段树"></a>为什么用线段树</h2><p>从定义中得知，线段树的最大优势是“一劳永逸”，适用于有多次区间查询，修改的情况，</p><p>像这样：</p><blockquote><p>已知一个数列，你需要进行下面三种操作：</p><p>1.将某区间每一个数加上k</p><p>2.将某区间某一个数加上k</p><p>3.求出某区间每一个数的和</p></blockquote><h2 id="线段树怎么用"><a href="#线段树怎么用" class="headerlink" title="线段树怎么用"></a>线段树怎么用</h2><p>线段树有多种版本</p><h3 id="最基础经典的线段树"><a href="#最基础经典的线段树" class="headerlink" title="最基础经典的线段树"></a>最<del>基础</del>经典的线段树</h3><p>总体利用二叉树的一个简单的规律：</p><blockquote><p>root×2&#x3D;leaf1，root×2+1&#x3D;leaf2</p></blockquote><h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><p>介绍递归建树的方式</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 建树(当前节点，当前区间左边界，当前区间右边界)&#123;</span><br><span class="line">    tree[当前节点].左边界=当前区间左边界,tree[当前节点].右边界=当前区间右边界;</span><br><span class="line">    <span class="keyword">if</span>(区间左边界==区间右边界)&#123;  <span class="comment">//缩小到只包含一个节点了</span></span><br><span class="line">        tree[当前节点].val=轮到的节点值;    <span class="comment">//也可以认为是当前读到的值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则继续递归(二分)</span></span><br><span class="line">    当前区间中点=(当前区间左边界+当前区间右边界)/<span class="number">2</span>;</span><br><span class="line">    建树(当前节点左子节点编号,当前区间左边界,当前区间中点);</span><br><span class="line">    建树(当前节点右子节点编号,当前区间中点,当前区间右边界);</span><br><span class="line">    向上传值(当前节点); <span class="comment">//为了之后的计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[pos].l=l,tree[pos].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[pos].val=arr[p];  <span class="comment">//tree[pos].val=read();</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(pos&lt;&lt;<span class="number">1</span>,l,mid); <span class="comment">//build(pos*2,l,mid);</span></span><br><span class="line">    <span class="built_in">build</span>(pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid,r);  <span class="comment">//build(pos*2+1,mid,r);</span></span><br><span class="line">    <span class="built_in">pushup</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h4><p>利用规律二分查找</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> 单点查询(想要找点的位置，当前节点的位置)&#123;</span><br><span class="line">    <span class="keyword">if</span>(找到了)&#123;</span><br><span class="line">        <span class="keyword">return</span> 当前节点的值;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分</span></span><br><span class="line">    当前区间中点的位置=(当前节点的左子点+当前节点的右子点)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(当前区间中点的位置&gt;想要改的点的位置)&#123;</span><br><span class="line">        单点修改(想要改的点的位置，当前节点的位置*<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        单点修改(想要改的点的位置，当前节点的位置*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//高级操作(当前节点); //如果有需要</span></span><br><span class="line">    <span class="comment">//向上传值(当前节点); //如果有需要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">one_query</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==now)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[pos].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pushdown(now)  //if necessary</span></span><br><span class="line">    <span class="type">int</span> mid=(tree[now].r+tree[now].l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;pos)&#123;</span><br><span class="line">        <span class="built_in">one_query</span>(tree[now].l,pos,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">one_query</span>(tree[now].r,pos,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h4><p>也是采用二分的思想，与单点查询相似</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 单点修改(想要改的点的位置，当前节点的位置，要改成的值)&#123;</span><br><span class="line">    <span class="keyword">if</span>(找到了)&#123;</span><br><span class="line">        修改;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分</span></span><br><span class="line">    当前区间中点的位置=(当前节点的左子点+当前节点的右子点)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(当前区间中点的位置&gt;想要改的点的位置)&#123;</span><br><span class="line">        单点修改(想要改的点的位置，当前节点的左子节点，要改成的值);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        单点修改(想要改的点的位置，当前节点的右子节点，要改成的值);</span><br><span class="line">    &#125;</span><br><span class="line">    向上传值(当前节点);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">one_update</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> now,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==now)&#123;</span><br><span class="line">        tree[pos].val=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tree[now].r+tree[now].l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;pos)&#123;</span><br><span class="line">        <span class="built_in">one_update</span>(tree[now].l,pos,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">one_update</span>(tree[now].r,pos,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于1.1与1.2的pushup()补充:</p><p>这里的pushup只需要有求和的功能,因此:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    tr[pos].val=(tr[pos&lt;&lt;<span class="number">1</span>].val+tr[pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间询问"><a href="#区间询问" class="headerlink" title="区间询问"></a>区间询问</h4><p>通过二分找到左边界点和右边界点，过程中对于区间内的点直接相加其值</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 区间查询(当前节点,要查的区间的左边界,要查的区间的右边界)&#123;</span><br><span class="line">    <span class="keyword">if</span>(当前这个点包含的字节点都在区间范围内)&#123;</span><br><span class="line">        <span class="keyword">return</span> 当前点的值;</span><br><span class="line">    &#125;</span><br><span class="line">    定义将要返回值为<span class="number">0</span></span><br><span class="line">    <span class="comment">//如果需要，放置一些高级操作的代码</span></span><br><span class="line">    <span class="comment">//开始二分</span></span><br><span class="line">    当前区间中点的位置=(当前节点的左子点+当前节点的右子点)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(当前区间中点的位置&gt;想要改的点的位置)&#123;</span><br><span class="line">        区间查询(当前节点的左子节点,要查的区间的左边界,要查的区间的右边界);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        区间查询(当前节点的右子节点,要查的区间的左边界,要查的区间的右边界);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[now].l=&gt;l&amp;&amp;tree[now].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[now].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//pushdown()</span></span><br><span class="line">    <span class="type">int</span> mid=(tree[now].l+tree[now].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;now)&#123;</span><br><span class="line">        <span class="built_in">query</span>(tree[now].l,l,r);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">query</span>(tree[now].r,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稍进阶的线段树"><a href="#稍进阶的线段树" class="headerlink" title="稍进阶的线段树"></a>稍进阶的线段树</h3><h4 id="区间更新"><a href="#区间更新" class="headerlink" title="区间更新"></a>区间更新</h4><p>显然，要求中还有能够实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是线段树&quot;&gt;&lt;a href=&quot;#什么是线段树&quot; class=&quot;headerlink&quot; title=&quot;什么是线段树&quot;&gt;&lt;/a&gt;什么是线段树&lt;/h2&gt;&lt;p&gt;线段树是种数据结构，通过数学的方式将线段变成树；&lt;/p&gt;
&lt;p&gt;用O(n)的时间预处理，之后可以用O(log</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Balance_Tree</title>
    <link href="http://iamzbk.github.io/2022/08/08/Balance-Tree/"/>
    <id>http://iamzbk.github.io/2022/08/08/Balance-Tree/</id>
    <published>2022-08-08T13:24:48.000Z</published>
    <updated>2022-08-08T13:25:23.894Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://iamzbk.github.io/2022/08/04/article-title/"/>
    <id>http://iamzbk.github.io/2022/08/04/article-title/</id>
    <published>2022-08-04T07:05:42.046Z</published>
    <updated>2022-08-04T07:07:20.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="First-Test"><a href="#First-Test" class="headerlink" title="First Test"></a><strong>First Test</strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;First-Test&quot;&gt;&lt;a href=&quot;#First-Test&quot; class=&quot;headerlink&quot; title=&quot;First Test&quot;&gt;&lt;/a&gt;&lt;strong&gt;First Test&lt;/strong&gt;&lt;/h2&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://iamzbk.github.io/2022/08/03/hello-world/"/>
    <id>http://iamzbk.github.io/2022/08/03/hello-world/</id>
    <published>2022-08-03T12:44:13.112Z</published>
    <updated>2022-08-04T07:55:20.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a><strong>Hello World!</strong></h1><h3 id="记创建的第一天"><a href="#记创建的第一天" class="headerlink" title="记创建的第一天;"></a>记创建的第一天;</h3><p>Good luck for the following days!</p><h2 id="●’◡’●"><a href="#●’◡’●" class="headerlink" title="(●’◡’●)"></a>(●’◡’●)</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World!&quot;&gt;&lt;/a&gt;&lt;strong&gt;Hello World!&lt;/strong&gt;&lt;/h1&gt;&lt;h3 id=&quot;记创建的第一天&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
